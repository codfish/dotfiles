#!/usr/bin/env zsh

# Make sure fnm bin is discoverable in the current process
ensure_fnm_env() {
  if ! type 'fnm' &> /dev/null; then
    local brew_prefix
    brew_prefix="$(brew --prefix)"
    if [[ -x "${brew_prefix}/bin/fnm" && ":$PATH:" != *":${brew_prefix}/bin:"* ]]; then
      export PATH="${brew_prefix}/bin:${PATH}"
    fi
  fi

  if type 'fnm' &> /dev/null; then
    # Initialize fnm for this non-interactive shell so Node shims are available.
    eval "$(fnm env --use-on-cd)"
    hash -r
  fi
}

# Use fnm to install latest node version
install_latest_node() {
  if type 'fnm' &> /dev/null; then
    e_header "Installing latest Node.js version..."

    fnm install --lts
    fnm default lts/latest
    fnm use lts/latest

    [[ $? ]] && e_success "Done"
  else
    printf "\n"
    e_error "Error: fnm not found."
    printf "Aborting...\n"
    exit
  fi
}

# `npx` is great for most things, but some things I prefer to have in the global
# scope so I can run them directly without thinking twice.
install_npm_packages() {
  # Check for npm
  if type 'npm' &> /dev/null; then
    e_header "Installing Node.js packages..."

    # Ensure globals land in a shared prefix so they're available across Node versions
    npm config set prefix "$HOME/.local"

    # Install packages globally
    npm install -g vercel \
      renamer@3 \
      npm-check \
      contentful-cli \
      @google/gemini-cli \
      @openai/codex \
      turbo \
      corepack \
      pnpm \
      nx

    corepack enable

    [[ $? ]] && e_success "Done"
  else
    printf "\n"
    e_error "Error: npm not found."
    printf "Aborting...\n"
    exit
  fi
}
